<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title></title>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: rgb(88, 72, 246)
   }

   pre .number {
     color: rgb(0, 0, 205);
   }

   pre .comment {
     color: rgb(76, 136, 107);
   }

   pre .keyword {
     color: rgb(0, 0, 255);
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>




</head>

<body>
<h1></h1>

<p>Of all the frustrating data manipulations to deal with in any programming language, dates and times are the worst in my opinion. In R, there are many different packages that use various functions to deal with dates, which lead to different classes of dates that are not always compatible. Depending on how your data is organized, there are different solutions to your date and time problems. Here, I&#39;ll show the way that I think is easiest to deal with dates depending on the organization of your data.</p>

<p>Ok so I find in public health data that birthdays and death days are the most common dates to be dealing with. In a dataset like the DHS, dates can either be found as three separate integer variables (month, day, year) or they can be in one character variable like &ldquo;05/03/2009&rdquo;. So let&#39;s start with the first situation, numeric dates. </p>

<h1>Numeric dates</h1>

<pre><code class="r">#Create some data
dates&lt;-as.data.frame(cbind(c(1,3,6,11,4,12,5,3), 
                           c(30,14,NA,NA,16,NA,20,31), 
                           c(1980, 1980, 1980, 1983,1983, 1983, 1986, 1980), 
                           c(2, NA, NA, NA, NA, 12, 4, NA), 
                           c(2, NA, NA, NA, NA, NA, 29, NA), 
                           c(1980, NA, NA, 1985, NA, 1983, 1987, NA)))
colnames(dates)&lt;-c(&quot;birth_month&quot;, &quot;birth_day&quot;, &quot;birth_year&quot;, &quot;death_month&quot;, &quot;death_day&quot;, &quot;death_year&quot;)
dates
</code></pre>

<pre><code>##   birth_month birth_day birth_year death_month death_day death_year
## 1           1        30       1980           2         2       1980
## 2           3        14       1980          NA        NA         NA
## 3           6        NA       1980          NA        NA         NA
## 4          11        NA       1983          NA        NA       1985
## 5           4        16       1983          NA        NA         NA
## 6          12        NA       1983          12        NA       1983
## 7           5        20       1986           4        29       1987
## 8           3        31       1980          NA        NA         NA
</code></pre>

<p>I&#39;ve included a lot of missing cells, even in birth date, because that&#39;s the most common problem that I have - birth and death data, especially from developing countries, is full of missing birth months or days.  </p>

<p>Ok, so what I would like to do here is to figure out if I have any infant mortalities in my sample size of 8. I find the easiest way to create a date object from three integer month/day/year variables is by using <strong>ISOdate()</strong>, which is just in base R. ISOdate() follows the following syntax: </p>

<p><strong>ISOdate(year, month, day, hour = 12, min = 0, sec = 0, tz = &ldquo;GMT&rdquo;)</strong></p>

<p>and if you had hours and minutes you could easily throw those in too into the ISOdatetime() function which is the same syntax. So let&#39;s create a birth date:</p>

<pre><code class="r">dates$DOB &lt;- ISOdate(dates$birth_year, dates$birth_month, dates$birth_day)
dates
</code></pre>

<pre><code>##   birth_month birth_day birth_year death_month death_day death_year                 DOB
## 1           1        30       1980           2         2       1980 1980-01-30 12:00:00
## 2           3        14       1980          NA        NA         NA 1980-03-14 12:00:00
## 3           6        NA       1980          NA        NA         NA                &lt;NA&gt;
## 4          11        NA       1983          NA        NA       1985                &lt;NA&gt;
## 5           4        16       1983          NA        NA         NA 1983-04-16 12:00:00
## 6          12        NA       1983          12        NA       1983                &lt;NA&gt;
## 7           5        20       1986           4        29       1987 1986-05-20 12:00:00
## 8           3        31       1980          NA        NA         NA 1980-03-31 12:00:00
</code></pre>

<p>This is super easy.  The column DOB that we have added to the dataframe is of class POSIXlt, which is a class of calendar date and time.  Since I don&#39;t have any time variables, I don&#39;t want it crowding up my dataset so I can use the function <strong>strptime()</strong> to get rid of it. Here&#39;s the syntax:</p>

<p><strong>strptime(x, format, tz = &ldquo;&rdquo;)</strong></p>

<p>where x is your POSIXlt object, and format is whatever the format is of that object (see below).  The <a href="http://astrostatistics.psu.edu/su07/R/html/base/html/strptime.html">strptime help file</a> is a good place to understand the formats.</p>

<pre><code class="r">dates$DOB &lt;- strptime(dates$DOB, format = &quot;%Y-%m-%d&quot;)
dates$DOD &lt;- strptime(ISOdate(dates$death_year, dates$death_month, dates$death_day), format = &quot;%Y-%m-%d&quot;)
</code></pre>

<p>You can, of course, do this in one step, which I&#39;ve done for death date. Now we can look at our dataset:</p>

<pre><code class="r">dates
</code></pre>

<pre><code>##   birth_month birth_day birth_year death_month death_day death_year        DOB        DOD
## 1           1        30       1980           2         2       1980 1980-01-30 1980-02-02
## 2           3        14       1980          NA        NA         NA 1980-03-14       &lt;NA&gt;
## 3           6        NA       1980          NA        NA         NA       &lt;NA&gt;       &lt;NA&gt;
## 4          11        NA       1983          NA        NA       1985       &lt;NA&gt;       &lt;NA&gt;
## 5           4        16       1983          NA        NA         NA 1983-04-16       &lt;NA&gt;
## 6          12        NA       1983          12        NA       1983       &lt;NA&gt;       &lt;NA&gt;
## 7           5        20       1986           4        29       1987 1986-05-20 1987-04-29
## 8           3        31       1980          NA        NA         NA 1980-03-31       &lt;NA&gt;
</code></pre>

<p>Now if we want age at death, we can use the <strong>difftime()</strong> function that follows the following syntax and produces a difftime object (which you can convert to numeric using as.numeric() if you want to, which I highly recommend):</p>

<p><strong>difftime(time1, time2, tz,units = c(&ldquo;auto&rdquo;, &ldquo;secs&rdquo;, &ldquo;mins&rdquo;, &ldquo;hours&rdquo;,&ldquo;days&rdquo;, &ldquo;weeks&rdquo;))</strong></p>

<pre><code class="r">dates$Age.atdeath &lt;- difftime(dates$DOD, dates$DOB, unit = &quot;days&quot;)
dates$Age.atdeath
</code></pre>

<pre><code>## Time differences in days
## [1]   3  NA  NA  NA  NA  NA 344  NA
## attr(,&quot;tzone&quot;)
## [1] &quot;&quot;
</code></pre>

<pre><code class="r">class(dates$Age.atdeath)
</code></pre>

<pre><code>## [1] &quot;difftime&quot;
</code></pre>

<pre><code class="r"># check if there were an infant mortalities
dates$Age.atdeath &lt; 365
</code></pre>

<pre><code>## [1] TRUE   NA   NA   NA   NA   NA TRUE   NA
</code></pre>

<p>Ok, I found two infant mortalities, but I see that there&#39;s a problem. I see that I&#39;m missing two birthdays that come up as NA, and this is because I&#39;m missing the birth day for those two people. However, I do have birth month and birth year, and this is information I don&#39;t want to lose. There are many ways to deal with this, including imputing birth days or assigning them randomly from a uniform distribution or whatever.  </p>

<p>In this case, what I will do is very simple - just replace the missing birth day with 1 if it&#39;s missing (and similarly replace a missing birth month with 1 if it&#39;s missing) and replace missing death month and day with 12 and 30, respectively. That way I have the maximum possible age at death and I don&#39;t lose potentially important information. There are a number of ways to accomplish what I want to do, but I love using the <strong>ifelse()</strong> function because I find it extremely intuitive so I will do that:</p>

<pre><code class="r">dates$DOB2&lt;-strptime(ISOdate(year=dates$birth_year, 
                             month=ifelse(is.na(dates$birth_month), 1, dates$birth_month), 
                             day=ifelse(is.na(dates$birth_day),1, dates$birth_day)), 
                     format=&quot;%Y-%m-%d&quot;)

dates$DOD2&lt;-strptime(ISOdate(year=dates$death_year, 
                             month=ifelse(is.na(dates$death_month),12,dates$death_month), 
                             day=ifelse(is.na(dates$death_day),30, dates$death_day)), 
                     format=&quot;%Y-%m-%d&quot;)

dates$Ageatdeath_2&lt;-as.numeric(difftime(dates$DOD2,dates$DOB2,unit=&quot;days&quot;))

dates[,c(1:6,10:12)]
</code></pre>

<pre><code>##   birth_month birth_day birth_year death_month death_day death_year       DOB2       DOD2 Ageatdeath_2
## 1           1        30       1980           2         2       1980 1980-01-30 1980-02-02            3
## 2           3        14       1980          NA        NA         NA 1980-03-14       &lt;NA&gt;           NA
## 3           6        NA       1980          NA        NA         NA 1980-06-01       &lt;NA&gt;           NA
## 4          11        NA       1983          NA        NA       1985 1983-11-01 1985-12-30          790
## 5           4        16       1983          NA        NA         NA 1983-04-16       &lt;NA&gt;           NA
## 6          12        NA       1983          12        NA       1983 1983-12-01 1983-12-30           29
## 7           5        20       1986           4        29       1987 1986-05-20 1987-04-29          344
## 8           3        31       1980          NA        NA         NA 1980-03-31       &lt;NA&gt;           NA
</code></pre>

<p>So now we see above that I have all birthdays completed, and I was able to reveal that I have another infant mortality in my data, and another death more generally. </p>

<h1>Character Dates</h1>

<p>Ok so onto the second type of dataset you may encounter, which is that somebody inputed the dates into Excel or whatever like this:</p>

<pre><code class="r">dates2&lt;-as.data.frame(cbind(c(1:5), 
                            c(&quot;8/31/70&quot;, &quot;NA&quot;, &quot;10/12/60&quot;, &quot;1/1/66&quot;, &quot;12/31/80&quot;), 
                            c(&quot;8/31/56&quot;, &quot;12-31-1977&quot;, &quot;12Aug55&quot;, &quot;July 31 1965&quot; ,&quot;30jan1952&quot;)))
colnames(dates2)&lt;-c(&quot;ID&quot;, &quot;date_factor&quot;, &quot;date_horrible&quot;)
dates2
</code></pre>

<pre><code>##   ID date_factor date_horrible
## 1  1     8/31/70       8/31/56
## 2  2          NA    12-31-1977
## 3  3    10/12/60       12Aug55
## 4  4      1/1/66  July 31 1965
## 5  5    12/31/80     30jan1952
</code></pre>

<p>In the first column at least all of the dates have the same format, but in the second (which happens really often!), every date is a different format which seems, at first, like a total nightmare. But fortunately R is here to rescue us. </p>

<p>Ok, let&#39;s start with the easy one. The tricky part with this kind of data is that R often immediately converts the dates to factors, like so:</p>

<pre><code class="r">class(dates2$date_factor)
</code></pre>

<pre><code>## [1] &quot;factor&quot;
</code></pre>

<p>This happens if you are reading in a csv file as well. You can either stop R from doing that by using the as.is option like so (assuming your dates were the second and third columns):  </p>

<pre><code class="r">df &lt;- read.table(&quot;data_with_dates.txt&quot;, header = TRUE, as.is = 2:3)
</code></pre>

<p>or we just have to remember to use the <strong>as.character()</strong> function before we do anything. Ok, so the point here is that even though these look like dates, they are <em>not</em> dates. They are factors or maybe characters, but not manipulatable like you would want. For example, this gives you the following error:</p>

<pre><code class="r"># NO: this gives an error, you can&#39;t do this with characters, need the date format
dates2$age &lt;- difftime(&quot;02/27/13&quot;, as.character(dates2$date_factor), unit = &quot;days&quot;)
</code></pre>

<pre><code>## Error: character string is not in a standard unambiguous format
</code></pre>

<p>So we need to get these character dates into actual date formats. If all of our formats are the same, we can use the chron package and the <strong>chron()</strong> function really easily like so. </p>

<p><strong>chron(dates., times., format = c(dates = &ldquo;m/d/y&rdquo;, times = &ldquo;h:m:s&rdquo;),out.format, origin.)</strong></p>

<p>where dates is the vector of <strong>character</strong> dates, and the format is whatever the format is of the data you have. Note that it yields warning messages because of the missing value, but that is ok.  </p>

<pre><code class="r">library(chron)
dates2$date.fmt &lt;- chron(as.character(dates2$date_factor), format = &quot;m/d/y&quot;)
</code></pre>

<pre><code>## Warning: wrong number of fields in entry(ies) 2
</code></pre>

<pre><code>## Warning: NAs introduced by coercion
</code></pre>

<pre><code>## Warning: NAs introduced by coercion
</code></pre>

<pre><code>## Warning: NAs introduced by coercion
</code></pre>

<pre><code class="r">class(dates2$date.fmt)
</code></pre>

<pre><code>## [1] &quot;dates&quot; &quot;times&quot;
</code></pre>

<pre><code class="r">dates2[, c(1, 2, 4)]
</code></pre>

<pre><code>##   ID date_factor date.fmt
## 1  1     8/31/70 08/31/70
## 2  2          NA     &lt;NA&gt;
## 3  3    10/12/60 10/12/60
## 4  4      1/1/66 01/01/66
## 5  5    12/31/80 12/31/80
</code></pre>

<p>Note that it looks very similar to the date_factor column but it is not, because it is now a dates and times class as I show above. We can also change how we want the outgoing format to look:</p>

<pre><code class="r">dates2$date.fmt &lt;- chron(as.character(dates2$date_factor), format = &quot;m/d/y&quot;, out.format = &quot;month day year&quot;)
dates2[, c(1, 2, 4)]
</code></pre>

<pre><code>##   ID date_factor         date.fmt
## 1  1     8/31/70   August 31 1970
## 2  2          NA             &lt;NA&gt;
## 3  3    10/12/60  October 12 1960
## 4  4      1/1/66  January 01 1966
## 5  5    12/31/80 December 31 1980
</code></pre>

<p>And now we can find the age of these people using <strong>difftime()</strong> as before. Let&#39;s say I interviewed everyone on March 1st of this year and I want their age in years at interview:</p>

<pre><code class="r">dates2$age &lt;- as.numeric(floor(difftime(chron(&quot;03/01/2013&quot;), dates2$date.fmt, unit = &quot;days&quot;)/360))
dates2[c(1, 2, 4, 5)]
</code></pre>

<pre><code>##   ID date_factor         date.fmt age
## 1  1     8/31/70   August 31 1970  43
## 2  2          NA             &lt;NA&gt;  NA
## 3  3    10/12/60  October 12 1960  53
## 4  4      1/1/66  January 01 1966  47
## 5  5    12/31/80 December 31 1980  32
</code></pre>

<p>I can also do things like add a day to everybody&#39;s date if I had some reason to do that, and I can compare dates to see which one came first, which can be useful:</p>

<pre><code class="r"># Add a day to everyone&#39;s date for some reason
dates2$date.fmt + 1
</code></pre>

<pre><code>## [1] September 01 1970 &lt;NA&gt;              October 13 1960   January 02 1966   January 01 1981
</code></pre>

<pre><code class="r"># Compare the date to some other date to see which came first using &lt; operator
dates2$date.fmt &lt; chron(&quot;04/02/62&quot;)
</code></pre>

<pre><code>## [1] FALSE    NA  TRUE FALSE FALSE
</code></pre>

<p>Ok finally what if your data is as horrible as what we see in our second column?</p>

<pre><code class="r">dates2[, c(1, 3)]
</code></pre>

<pre><code>##   ID date_horrible
## 1  1       8/31/56
## 2  2    12-31-1977
## 3  3       12Aug55
## 4  4  July 31 1965
## 5  5     30jan1952
</code></pre>

<p>Chron won&#39;t help us here, as it needs one format for everyone:</p>

<pre><code class="r"># NO: chron needs the same format
chron(as.character(dates2$date_horrible))
</code></pre>

<pre><code>## [1] 08/31/56 &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;
</code></pre>

<p>It just gives us NAs (and warnings, which I&#39;ve hid).  However, there is a package called <strong>date</strong> that will take any type of date and figure it out for us. Watch how amazing it is, the only argument to the function you need is the vector of <strong>character</strong> dates:</p>

<pre><code class="r">library(date)
# as.date (lower case) will correctly convert dates in vector
as.date(as.character(dates2$date_horrible))
</code></pre>

<pre><code>## [1] 31Aug56 31Dec77 12Aug55 31Jul65 30Jan52
</code></pre>

<p>Extraordinary! :) It just knows. However, I find that it stubbornly reformats itself into the number of days since 1960 when adding it as a column to the dataframe: </p>

<pre><code class="r">dates2$date_autofmt &lt;- as.date(as.character(dates2$date_horrible))
dates2[, c(1, 3, 6)]
</code></pre>

<pre><code>##   ID date_horrible date_autofmt
## 1  1       8/31/56        -1218
## 2  2    12-31-1977         6574
## 3  3       12Aug55        -1603
## 4  4  July 31 1965         2038
## 5  5     30jan1952        -2893
</code></pre>

<p>It&#39;s also not super easy to work with because it&#39;s a date object, not a Date object (VERY case-sensitive stuff here!). Feel free to chime in here if you have a better solution, but my simple fix on that is just to envelop it in an <strong>as.Date()</strong> function (from base R) like so: </p>

<pre><code class="r">dates2$date_amazing &lt;- as.Date(as.date(as.character(dates2$date_horrible)))
dates2[, c(1, 3, 7)]
</code></pre>

<pre><code>##   ID date_horrible date_amazing
## 1  1       8/31/56   1956-08-31
## 2  2    12-31-1977   1977-12-31
## 3  3       12Aug55   1955-08-12
## 4  4  July 31 1965   1965-07-31
## 5  5     30jan1952   1952-01-30
</code></pre>

<p>Now it works great. That&#39;s pretty incredible that one short line of code can transform your awful dates column into perfectly coordinated and workable dates. You can use <strong>difftime()</strong> the same way as before. Hope that this was useful for those pulling their hair out over date and time objects in R.</p>

<p>Also, if you made it all the way to the end, please enjoy <a href="http://www.youtube.com/watch?v=PD3aHKeFlSI">this hilarious episode</a> of Let&#39;s Make a Date on &ldquo;Whose Line Is It Anyway?&#39;&#39; featuring none other than Stephen Colbert. :D</p>

</body>

</html>

